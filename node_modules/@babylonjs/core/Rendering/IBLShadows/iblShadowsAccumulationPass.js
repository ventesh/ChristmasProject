
import { Vector4 } from "../../Maths/math.vector.js";
import { PostProcess } from "../../PostProcesses/postProcess.js";
import { RenderTargetTexture } from "../../Materials/Textures/renderTargetTexture.js";
/**
 * This should not be instanciated directly, as it is part of a scene component
 * @internal
 */
export class _IblShadowsAccumulationPass {
    /**
     * Gets the pass post process
     * @returns The post process
     */
    getPassPP() {
        return this._outputPP;
    }
    /**
     * Gets the debug pass post process
     * @returns The post process
     */
    getDebugPassPP() {
        if (!this._debugPassPP) {
            this._createDebugPass();
        }
        return this._debugPassPP;
    }
    /**
     * Gets the name of the debug pass
     * @returns The name of the debug pass
     */
    get debugPassName() {
        return this._debugPassName;
    }
    /**
     * A value that controls how much of the previous frame's accumulation to keep.
     * The higher the value, the faster the shadows accumulate but the more potential ghosting you'll see.
     */
    get remenance() {
        return this._remenance;
    }
    /**
     * A value that controls how much of the previous frame's accumulation to keep.
     * The higher the value, the faster the shadows accumulate but the more potential ghosting you'll see.
     */
    set remenance(value) {
        this._remenance = value;
    }
    /**
     * Reset the accumulation.
     */
    get reset() {
        return this._reset;
    }
    /**
     * Reset the accumulation.
     */
    set reset(value) {
        this._reset = value;
    }
    /**
     * Sets params that control the position and scaling of the debug display on the screen.
     * @param x Screen X offset of the debug display (0-1)
     * @param y Screen Y offset of the debug display (0-1)
     * @param widthScale X scale of the debug display (0-1)
     * @param heightScale Y scale of the debug display (0-1)
     */
    setDebugDisplayParams(x, y, widthScale, heightScale) {
        this._debugSizeParams.set(x, y, widthScale, heightScale);
    }
    /**
     * Creates the debug post process effect for this pass
     */
    _createDebugPass() {
        if (!this._debugPassPP) {
            const isWebGPU = this._engine.isWebGPU;
            const debugOptions = {
                width: this._engine.getRenderWidth(),
                height: this._engine.getRenderHeight(),
                textureFormat: 7,
                textureType: 0,
                samplingMode: 1,
                uniforms: ["sizeParams"],
                samplers: ["debugSampler"],
                engine: this._engine,
                reusable: false,
                shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,
                extraInitializations: (useWebGPU, list) => {
                    if (useWebGPU) {
                        list.push(import("../../ShadersWGSL/iblShadowDebug.fragment.js"));
                    }
                    else {
                        list.push(import("../../Shaders/iblShadowDebug.fragment.js"));
                    }
                },
            };
            this._debugPassPP = new PostProcess(this.debugPassName, "iblShadowDebug", debugOptions);
            this._debugPassPP.autoClear = false;
            this._debugPassPP.onApplyObservable.add((effect) => {
                // update the caustic texture with what we just rendered.
                effect.setTextureFromPostProcessOutput("debugSampler", this._outputPP);
                effect.setVector4("sizeParams", this._debugSizeParams);
            });
        }
    }
    /**
     * Instantiates the accumulation pass
     * @param scene Scene to attach to
     * @returns The accumulation pass
     */
    constructor(scene) {
        /** Enable the debug view for this pass */
        this.debugEnabled = false;
        this._debugPassName = "Shadow Accumulation Debug Pass";
        this._remenance = 0.9;
        this._reset = true;
        this._debugSizeParams = new Vector4(0.0, 0.0, 0.0, 0.0);
        this._scene = scene;
        this._engine = scene.getEngine();
        this._createTextures();
    }
    _createTextures() {
        const isWebGPU = this._engine.isWebGPU;
        // Create the local position texture for the previous frame.
        // We'll copy the previous local position texture to this texture at the start of every frame.
        const localPositionOptions = {
            generateDepthBuffer: false,
            generateMipMaps: false,
            format: 5,
            type: 2,
            samplingMode: 2,
        };
        this._oldLocalPositionRT = new RenderTargetTexture("oldLocalPositionRT", { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, this._scene, localPositionOptions);
        const localPositionCopyOptions = {
            width: this._engine.getRenderWidth(),
            height: this._engine.getRenderHeight(),
            textureFormat: 5,
            textureType: 2,
            samplingMode: 1,
            engine: this._engine,
            reusable: false,
            defines: "#define PASS_SAMPLER sampler",
            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,
            extraInitializations: (useWebGPU, list) => {
                if (useWebGPU) {
                    list.push(import("../../ShadersWGSL/pass.fragment.js"));
                }
                else {
                    list.push(import("../../Shaders/pass.fragment.js"));
                }
            },
        };
        const localPositionCopyPP = new PostProcess("Copy Local Position Texture", "pass", localPositionCopyOptions);
        localPositionCopyPP.autoClear = false;
        localPositionCopyPP.onApplyObservable.add((effect) => {
            const prePassRenderer = this._scene.prePassRenderer;
            const index = prePassRenderer.getIndex(1);
            if (index >= 0)
                effect.setTexture("textureSampler", prePassRenderer.getRenderTarget().textures[index]);
        });
        this._oldLocalPositionRT.addPostProcess(localPositionCopyPP);
        this._oldLocalPositionRT.skipInitialClear = true;
        this._oldLocalPositionRT.noPrePassRenderer = true;
        this._scene.customRenderTargets.push(this._oldLocalPositionRT);
        // Create the accumulation texture for the previous frame.
        // We'll copy the output of the accumulation pass to this texture at the start of every frame.
        const accumulationOptions = {
            generateDepthBuffer: false,
            generateMipMaps: false,
            format: 7,
            type: 2,
            samplingMode: 1,
        };
        this._oldAccumulationRT = new RenderTargetTexture("oldAccumulationRT", { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, this._scene, accumulationOptions);
        const accumulationCopyOptions = {
            width: this._engine.getRenderWidth(),
            height: this._engine.getRenderHeight(),
            textureFormat: 7,
            textureType: 2,
            samplingMode: 1,
            engine: this._engine,
            reusable: false,
            defines: "#define PASS_SAMPLER sampler",
            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,
            extraInitializations: (useWebGPU, list) => {
                if (useWebGPU) {
                    list.push(import("../../ShadersWGSL/pass.fragment.js"));
                }
                else {
                    list.push(import("../../Shaders/pass.fragment.js"));
                }
            },
        };
        const accumulationCopyPP = new PostProcess("Copy Accumulation Texture", "pass", accumulationCopyOptions);
        accumulationCopyPP.autoClear = false;
        accumulationCopyPP.onApplyObservable.add((effect) => {
            if (this._outputPP._outputTexture?.texture) {
                effect.setTextureFromPostProcessOutput("textureSampler", this._outputPP);
            }
            else {
                // We must set a texture. It's not the right one, but we must set something before the right one is available (see above), probably on next frame.
                effect._bindTexture("textureSampler", this._outputPP.inputTexture.texture);
            }
        });
        this._oldAccumulationRT.addPostProcess(accumulationCopyPP);
        this._oldAccumulationRT.skipInitialClear = true;
        this._oldAccumulationRT.noPrePassRenderer = true;
        this._scene.customRenderTargets.push(this._oldAccumulationRT);
        // Now, create the accumulation pass
        const ppOptions = {
            width: this._engine.getRenderWidth(),
            height: this._engine.getRenderHeight(),
            textureFormat: 7,
            textureType: 2,
            samplingMode: 1,
            uniforms: ["accumulationParameters"],
            samplers: ["oldAccumulationSampler", "prevLocalPositionSampler", "localPositionSampler", "motionSampler"],
            engine: this._engine,
            reusable: false,
            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,
            extraInitializations: (useWebGPU, list) => {
                if (useWebGPU) {
                    list.push(import("../../ShadersWGSL/iblShadowAccumulation.fragment.js"));
                }
                else {
                    list.push(import("../../Shaders/iblShadowAccumulation.fragment.js"));
                }
            },
        };
        this._outputPP = new PostProcess("accumulationPassPP", "iblShadowAccumulation", ppOptions);
        this._outputPP.autoClear = false;
        this._outputPP.resize(this._engine.getRenderWidth(), this._engine.getRenderHeight()); // make sure that _outputPP.inputTexture.texture is created right away
        this._outputPP.onApplyObservable.add((effect) => {
            this._updatePostProcess(effect);
        });
    }
    _updatePostProcess(effect) {
        effect.setVector4("accumulationParameters", new Vector4(this.remenance, this.reset ? 1.0 : 0.0, 0.0, 0.0));
        effect.setTexture("oldAccumulationSampler", this._oldAccumulationRT);
        effect.setTexture("prevLocalPositionSampler", this._oldLocalPositionRT);
        const prePassRenderer = this._scene.prePassRenderer;
        if (prePassRenderer) {
            const localPositionIndex = prePassRenderer.getIndex(1);
            if (localPositionIndex >= 0)
                effect.setTexture("localPositionSampler", prePassRenderer.getRenderTarget().textures[localPositionIndex]);
            const velocityIndex = prePassRenderer.getIndex(11);
            if (velocityIndex >= 0)
                effect.setTexture("motionSampler", prePassRenderer.getRenderTarget().textures[velocityIndex]);
        }
        this.reset = false;
    }
    /** Called by render pipeline when canvas resized. */
    resize() {
        this._oldAccumulationRT.resize({ width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() });
        this._oldLocalPositionRT.resize({ width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() });
    }
    _disposeTextures() {
        this._oldAccumulationRT.dispose();
        this._oldLocalPositionRT.dispose();
    }
    /**
     * Checks if the pass is ready
     * @returns true if the pass is ready
     */
    isReady() {
        return (this._oldAccumulationRT &&
            this._oldAccumulationRT.isReadyForRendering() &&
            this._oldLocalPositionRT &&
            this._oldLocalPositionRT.isReadyForRendering() &&
            this._outputPP.isReady() &&
            !(this._debugPassPP && !this._debugPassPP.isReady()));
    }
    /**
     * Disposes the associated resources
     */
    dispose() {
        this._disposeTextures();
        this._outputPP.dispose();
        if (this._debugPassPP) {
            this._debugPassPP.dispose();
        }
    }
}
//# sourceMappingURL=iblShadowsAccumulationPass.js.map
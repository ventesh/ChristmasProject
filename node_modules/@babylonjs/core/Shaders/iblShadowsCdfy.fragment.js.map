{"version":3,"file":"iblShadowsCdfy.fragment.js","sourceRoot":"","sources":["../../../../dev/core/src/Shaders/iblShadowsCdfy.fragment.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AAErD,MAAM,IAAI,GAAG,2BAA2B,CAAC;AACzC,MAAM,MAAM,GAAG;;;;;;;;;;;;;;;;;;;;;;;;sCAwBuB,CAAC;AACvC,aAAa;AACb,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AACxC,gBAAgB;AAChB,MAAM,CAAC,MAAM,yBAAyB,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"iblShadowsCdfyPixelShader\";\nconst shader = `precision highp sampler2D;precision highp samplerCube;\n#define PI 3.1415927\nvarying vec2 vUV;\n#ifdef IBL_USE_CUBE_MAP\nuniform samplerCube iblSource;\n#else\nuniform sampler2D iblSource;\n#endif\nuniform int iblHeight;\n#ifdef IBL_USE_CUBE_MAP\nvec3 equirectangularToCubemapDirection(vec2 uv) {float longitude=uv.x*2.0*PI-PI;float latitude=PI*0.5-uv.y*PI;vec3 direction;direction.x=cos(latitude)*sin(longitude);direction.y=sin(latitude);direction.z=cos(latitude)*cos(longitude);return direction;}\nfloat fetchCube(vec2 uv) {vec3 direction=equirectangularToCubemapDirection(uv);return sin(PI*uv.y)*dot(textureCubeLodEXT(iblSource,direction,0.0).rgb,\nvec3(0.3,0.6,0.1));}\n#else\nfloat fetchPanoramic(ivec2 Coords,float envmapHeight) {return sin(PI*(float(Coords.y)+0.5)/envmapHeight) *\ndot(texelFetch(iblSource,Coords,0).rgb,vec3(0.3,0.6,0.1));}\n#endif\nvoid main(void) {ivec2 coords=ivec2(gl_FragCoord.x,gl_FragCoord.y);float cdfy=0.0;for (int y=1; y<=coords.y; y++) {\n#ifdef IBL_USE_CUBE_MAP\nvec2 uv=vec2(vUV.x,(float(y-1)+0.5)/float(iblHeight));cdfy+=fetchCube(uv);\n#else\ncdfy+=fetchPanoramic(ivec2(coords.x,y-1),float(iblHeight));\n#endif\n}\ngl_FragColor=vec4(cdfy,0.0,0.0,1.0);}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const iblShadowsCdfyPixelShader = { name, shader };\n"]}
{"version":3,"file":"iblShadowsIcdfx.fragment.js","sourceRoot":"","sources":["../../../../dev/core/src/Shaders/iblShadowsIcdfx.fragment.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AAErD,MAAM,IAAI,GAAG,4BAA4B,CAAC;AAC1C,MAAM,MAAM,GAAG;;;;;;;;;;gLAUiK,CAAC;AACjL,aAAa;AACb,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AACxC,gBAAgB;AAChB,MAAM,CAAC,MAAM,0BAA0B,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"iblShadowsIcdfxPixelShader\";\nconst shader = `precision highp sampler2D;\n#define PI 3.1415927\nvarying vec2 vUV;uniform sampler2D cdfx;float fetchCDF(int x) {return texelFetch(cdfx,ivec2(x,0),0).x;}\nfloat bisect(int size,float targetValue)\n{int a=0,b=size-1;while (b-a>1) {int c=a+b>>1;if (fetchCDF(c)<targetValue)\na=c;else\nb=c;}\nreturn mix(float(a),float(b),(targetValue-fetchCDF(a))/(fetchCDF(b)-fetchCDF(a)))/float(size-1);}\nvoid main(void) {ivec2 cdfSize=textureSize(cdfx,0);int cdfWidth=cdfSize.x;int icdfWidth=cdfWidth-1;ivec2 currentPixel=ivec2(gl_FragCoord.xy);if (currentPixel.x==0)\n{gl_FragColor=vec4(0.0);}\nelse if (currentPixel.x==icdfWidth-1) {gl_FragColor=vec4(1.0);} else {float targetValue=fetchCDF(cdfWidth-1)*vUV.x;gl_FragColor=vec4(vec3(bisect(cdfWidth,targetValue)),1.0);}}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const iblShadowsIcdfxPixelShader = { name, shader };\n"]}
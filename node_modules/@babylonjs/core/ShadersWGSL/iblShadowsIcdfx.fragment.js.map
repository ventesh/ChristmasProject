{"version":3,"file":"iblShadowsIcdfx.fragment.js","sourceRoot":"","sources":["../../../../dev/core/src/ShadersWGSL/iblShadowsIcdfx.fragment.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AAErD,MAAM,IAAI,GAAG,4BAA4B,CAAC;AAC1C,MAAM,MAAM,GAAG;;;;;;;;;iNASkM,CAAC;AAClN,aAAa;AACb,WAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAC5C,gBAAgB;AAChB,MAAM,CAAC,MAAM,8BAA8B,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"iblShadowsIcdfxPixelShader\";\nconst shader = `#define PI 3.1415927\nvarying vUV: vec2f;var cdfx: texture_2d<f32>;fn fetchCDF(x: u32)->f32 {return textureLoad(cdfx, vec2u(x,0),0).x;}\nfn bisect(size: u32,targetValue: f32)->f32\n{var a: u32=0;var b=size-1;while (b-a>1) {var c: u32=(a+b)>>1;if (fetchCDF(c)<targetValue) {a=c;}\nelse {b=c;}}\nreturn mix( f32(a), f32(b),(targetValue-fetchCDF(a))/(fetchCDF(b)-fetchCDF(a)))/ f32(size-1);}\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var cdfSize: vec2u=textureDimensions(cdfx,0);var cdfWidth: u32=cdfSize.x;var icdfWidth: u32=cdfWidth-1;var currentPixel: vec2u= vec2u(fragmentInputs.position.xy);if (currentPixel.x==0)\n{fragmentOutputs.color= vec4f(0.0);}\nelse if (currentPixel.x==icdfWidth-1) {fragmentOutputs.color= vec4f(1.0);} else {var targetValue: f32=fetchCDF(cdfWidth-1)*input.vUV.x;fragmentOutputs.color= vec4f( vec3f(bisect(cdfWidth,targetValue)),1.0);}}`;\n// Sideeffect\nShaderStore.ShadersStoreWGSL[name] = shader;\n/** @internal */\nexport const iblShadowsIcdfxPixelShaderWGSL = { name, shader };\n"]}
{"version":3,"file":"iblShadowAccumulation.fragment.js","sourceRoot":"","sources":["../../../../dev/core/src/ShadersWGSL/iblShadowAccumulation.fragment.ts"],"names":[],"mappings":"AAAA,eAAe;AACf,OAAO,EAAE,WAAW,EAAE,MAAM,wBAAwB,CAAC;AAErD,MAAM,IAAI,GAAG,kCAAkC,CAAC;AAChD,MAAM,MAAM,GAAG;;;;;;;;;;;;;;;uBAeQ,CAAC;AACxB,aAAa;AACb,WAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAC5C,gBAAgB;AAChB,MAAM,CAAC,MAAM,oCAAoC,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC","sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"iblShadowAccumulationPixelShader\";\nconst shader = `varying vUV: vec2f;uniform accumulationParameters: vec4f;\n#define remanence uniforms.accumulationParameters.x\n#define resetb uniforms.accumulationParameters.y\nvar motionSampler: texture_2d<f32>; \nvar localPositionSampler: texture_2d<f32>; \nvar textureSampler: texture_2d<f32>; \nvar oldAccumulationSamplerSampler: sampler;var oldAccumulationSampler: texture_2d<f32>; \nvar prevLocalPositionSamplerSampler: sampler;var prevLocalPositionSampler: texture_2d<f32>; \nfn max2(v: vec2f,w: vec2f)->vec2f { \nreturn vec2f(max(v.x,w.x),max(v.y,w.y)); }\nfn lessThan(x: vec2f,y: vec2f)->vec2<bool> {return x<y;}\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var reset: bool= bool(resetb);var Resolution: vec2f= vec2f(textureDimensions(textureSampler,0));var currentPixel: vec2i= vec2i(input.vUV*Resolution);var LP: vec4f=textureLoad(localPositionSampler,currentPixel,0);if (0.0==LP.w) {fragmentOutputs.color=vec4f(1.0,0.0,0.0,1.0);return fragmentOutputs;}\nvar velocityColor: vec2f=textureLoad(motionSampler,currentPixel,0).xy;var prevCoord: vec2f=input.vUV+velocityColor;var PrevLP: vec3f=textureSampleLevel(prevLocalPositionSampler,prevLocalPositionSamplerSampler,prevCoord,0.0).xyz;var PrevShadows: vec2f=textureSampleLevel(oldAccumulationSampler,oldAccumulationSamplerSampler,prevCoord,0.0).xy;var newShadows: f32=textureLoad(textureSampler,currentPixel,0).x;PrevShadows.y=select(1.0,max(PrevShadows.y/(1.0+PrevShadows.y),1.0-remanence),!reset && all(lessThan(abs(prevCoord- vec2f(0.5)), vec2f(0.5))) &&\ndistance(LP.xyz,PrevLP)<5e-2);PrevShadows=max( vec2f(0.0),PrevShadows);fragmentOutputs.color= vec4f(mix(PrevShadows.x,newShadows,PrevShadows.y),\nPrevShadows.y,0,1.0);}`;\n// Sideeffect\nShaderStore.ShadersStoreWGSL[name] = shader;\n/** @internal */\nexport const iblShadowAccumulationPixelShaderWGSL = { name, shader };\n"]}